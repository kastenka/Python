# GIL. Глобальная блокировка интерпретатора
"""GIL очень тесно связан с выполнением потоков. GIL не позволяет одновременно не позволяет двум потокам выполняться
одновременно на одном ядре процессора, даже если ядер несколько. GIL в первую очередь предназначен для защиты памяти
интерпретатора от разрушений и делает операции с памятью атомарными."""


"""Если у нас задача cpu bound programm - программа, которая будет потреблять только центральный процессор,не делает 
операций ввода/вывода и тд, то код, написанный с использованием потоков, будет не эффективный - работает медленее, 
чем код запущенный последовательно"""
from threading import Thread
import time


def count(n):
    while n > 0:
        n -= 1


# series run
t0 = time.time()
count(100_000_000)
count(100_000_000)
print(time.time() - t0)

# parallel run - выполнение при помощи потоков займет больше времени(из-за глобальной блокировки интерпретатора)
# Потоки, при выполнении своего кода, каждый раз получают блокировку интерпретатора
t0 = time.time()
th1 = Thread(target=count, args=(100_000_000,))
th2 = Thread(target=count, args=(100_000_000,))

th1.start(); th2.start()
th1.join(); th2.join()  # ждем пока завершатся потоки
print(time.time() - t0)


# !!! Если код функции заменим на задачу, которая требует операций ввода/вывода, то заметим большой прирост в итоговом
# времени выполнения последовательного кода

# Код с потоками хорошо параллелиться при вводе/выводе

# Все потоки спят 5 миллисекунд в ожидании получения блокировки

# В Python3 если работает один главный поток, то он не требует освобождения глобальной блокировки интерпретатора
# Все потоки выполняются с захватом GIL, но для системных вызовов и операци1 ввода/вывода не нужен GIL
