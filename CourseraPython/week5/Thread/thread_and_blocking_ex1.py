# Синхронизация потоков, блокировки
# !!!Для синхронизации работы потоков предпочительнее использовать очереди!!!

# Иногда приходится использовать блокировки, которые как минимум замедляют работу программы
import threading


# Предположим есть класс Point, у которого есть координаты x и y
class Point(object):
    def __init__(self):
        self._mutex = threading.RLock() # создаем объект блокировки через вызов конструкции threading.RLock()
        self._x = 0
        self._y = 0

    # возвращает коориданты
    def get(self):
        # при помощи контекстного менеджера захватываем блокировку, при выходе из него - блокировка высвобождается
        with self._mutex:
            return self._x, self._y

    # задает координаты
    def set(self, x, y):
        with self._mutex:
            self._x = x
            self._y = y


"""Предположим, что создали объект класса Point и используем этот объект в большом количестве потоков. Эти потоки,
некоторые вызывают метод get, некоторые вызывают метод set.
Если бы не было блокировок, то может возникнуть такая ситуация, когда один поток изменил значение переменной x, а другой
поток в это время вернул координаты x и y - те получили неконсистентное состояние объекта, когда частично изменена одна
координата, а вторая нет.
Чтобы избежать подобных ситуаций нужны блокировки.
"""