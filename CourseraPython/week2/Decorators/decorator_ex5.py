import functools  # для работы с функциями


# Полезно определить декоратор, чтобы мог применяться не только к функциям, которые принимают один параметр, а к
# функциям, которые принимают любое количество аргументов, любое количество параметров
def logger(func):

    @functools.wraps(func)  # позволяет подменять docstring и названия
    # определяем функцию так, чтобы она принимала любое количество аргументов
    def wrapped(*args, **kwargs):
        result = func(*args, **kwargs)  # передаём все аргументы, которые пришли в исходную функцию
        with open("log.txt", "w") as f:
            f.write(str(result))
        return result  # возвращаем result, чтобы все работало(чтобы вызвалась функция и вернулось ее значение)
    return wrapped


@logger
def summator(num_list):
    return sum(num_list)


# оказывается, что summator является wrapped, тк функция подменяется
# часто это бывает неудобно для отладки - тк важно понимать, в какой функции произошло исключение
# можно использовать в декораторе встроенный метод functools.wraps - позволяет не подменять функции
print(summator.__name__)
